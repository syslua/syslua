local prio = require('syslua.priority')
local lib = require('syslua.lib')

---@class syslua.environment.variables
local M = {}

---@class syslua.environment.variables.Options: table<string, syslua.OptionValue<string>>

-- Platform-specific path separators
local PATH_SEP = sys.os == 'windows' and ';' or ':'

-- Default PATH values
local DEFAULT_PATH = sys.os == 'windows' and 'C:\\Windows\\System32;C:\\Windows;C:\\Windows\\System32\\Wbem'
  or '/usr/local/bin:/usr/bin:/bin'

local default_opts = {
  PATH = prio.mergeable({
    separator = PATH_SEP,
    default = DEFAULT_PATH,
  }),
}

---@type syslua.environment.variables.Options
M.opts = default_opts

-- ============================================================================
-- Helper Functions
-- ============================================================================

--- Escape a string for POSIX shell (bash/zsh)
---@param str string
---@return string
local function escape_posix(str)
  -- Escape single quotes by ending quote, adding escaped quote, starting quote
  return "'" .. str:gsub("'", "'\\''") .. "'"
end

--- Escape a string for fish shell
---@param str string
---@return string
local function escape_fish(str)
  -- Fish uses single quotes with \' for escape
  return "'" .. str:gsub("'", "\\'") .. "'"
end

--- Escape a string for PowerShell
---@param str string
---@return string
local function escape_powershell(str)
  -- PowerShell uses single quotes, double them to escape
  return "'" .. str:gsub("'", "''") .. "'"
end

--- Escape a string for use in sed regex patterns
--- Escapes special characters: # / \ . [ ] * ^ $
---@param str string
---@return string
local function escape_sed_pattern(str)
  return str:gsub('([#/\\%.%[%]%*%^%$])', '\\%1')
end

--- Get shell config file paths based on privilege level
---@return table<string, string>
local function get_shell_configs()
  local home = lib.get_home()

  if sys.is_elevated then
    -- Global config paths
    local bash_global = sys.os == 'darwin' and '/etc/profile' or '/etc/profile.d/syslua-env.sh'
    return {
      zsh = '/etc/zshenv',
      bash = bash_global,
      fish = '/etc/fish/conf.d/syslua-env.fish',
      powershell = 'C:\\Program Files\\PowerShell\\7\\profile.ps1',
    }
  else
    -- User config paths
    return {
      zsh = home .. '/.zshenv',
      bash = home .. '/.bashrc',
      fish = home .. '/.config/fish/config.fish',
      powershell = home .. '/Documents/PowerShell/profile.ps1',
    }
  end
end

--- Extract environment variables from merged opts
--- Note: opts is a MergedTable whose __pairs resolves all values
---@param opts syslua.environment.variables.Options
---@return table<string, string>
local function extract_env_vars(opts)
  local vars = {}

  for k, v in pairs(opts) do
    if type(v) == 'string' then
      vars[k] = v
    end
  end

  return vars
end

--- Generate bash/zsh env file content
---@param vars table<string, string>
---@return string
local function generate_posix_env(vars)
  local lines = {
    '# Generated by syslua - DO NOT EDIT',
    '# This file sets environment variables managed by syslua',
    '',
  }

  for name, value in pairs(vars) do
    table.insert(lines, 'export ' .. name .. '=' .. escape_posix(value))
  end

  table.insert(lines, '')
  return table.concat(lines, '\n')
end

--- Generate fish env file content
---@param vars table<string, string>
---@return string
local function generate_fish_env(vars)
  local lines = {
    '# Generated by syslua - DO NOT EDIT',
    '# This file sets environment variables managed by syslua',
    '',
  }

  for name, value in pairs(vars) do
    table.insert(lines, 'set -gx ' .. name .. ' ' .. escape_fish(value))
  end

  table.insert(lines, '')
  return table.concat(lines, '\n')
end

--- Generate PowerShell env file content
---@param vars table<string, string>
---@return string
local function generate_powershell_env(vars)
  local lines = {
    '# Generated by syslua - DO NOT EDIT',
    '# This file sets environment variables managed by syslua',
    '',
  }

  for name, value in pairs(vars) do
    table.insert(lines, '$env:' .. name .. ' = ' .. escape_powershell(value))
  end

  table.insert(lines, '')
  return table.concat(lines, '\n')
end

-- ============================================================================
-- Build and Bind Steps
-- ============================================================================

--- Create the build step that generates env files
---@param opts syslua.environment.variables.Options
---@return table
local function create_env_build(opts)
  local vars = extract_env_vars(opts)

  return sys.build({
    id = '__syslua_env',
    replace = true,
    inputs = {
      vars = vars,
      os = sys.os,
    },
    create = function(inputs, ctx)
      local posix_content = generate_posix_env(inputs.vars)
      local fish_content = generate_fish_env(inputs.vars)
      local ps_content = generate_powershell_env(inputs.vars)

      -- Write env files
      if sys.os == 'windows' then
        ctx:exec({
          bin = 'powershell.exe',
          args = {
            '-NoProfile',
            '-Command',
            string.format('Set-Content -Path "%s/syslua-env.ps1" -Value %s', ctx.out, escape_powershell(ps_content)),
          },
        })
      else
        ctx:exec({
          bin = '/bin/sh',
          args = {
            '-c',
            string.format('cat > "%s/syslua-env.sh" << \'SYSLUA_EOF\'\n%sSYSLUA_EOF', ctx.out, posix_content),
          },
        })
        ctx:exec({
          bin = '/bin/sh',
          args = {
            '-c',
            string.format('cat > "%s/syslua-env.fish" << \'SYSLUA_EOF\'\n%sSYSLUA_EOF', ctx.out, fish_content),
          },
        })
      end

      return {
        sh = ctx.out .. '/syslua-env.sh',
        fish = ctx.out .. '/syslua-env.fish',
        ps1 = ctx.out .. '/syslua-env.ps1',
      }
    end,
  })
end

--- Create bind steps to source env files from shell configs
---@param build table Build outputs reference
local function create_env_binds(build)
  local shell_configs = get_shell_configs()

  -- Marker for identifying our block
  local BEGIN_MARKER = '# BEGIN SYSLUA ENV - DO NOT EDIT'
  local END_MARKER = '# END SYSLUA ENV'

  if sys.os == 'windows' then
    -- PowerShell bind
    sys.bind({
      inputs = {
        build = build,
        config_path = shell_configs.powershell,
        begin_marker = BEGIN_MARKER,
        end_marker = END_MARKER,
      },
      create = function(inputs, ctx)
        -- Create profile directory if needed and add source line
        ctx:exec({
          bin = 'powershell.exe',
          args = {
            '-NoProfile',
            '-Command',
            string.format(
              [[
$configPath = '%s'
$configDir = Split-Path -Parent $configPath
if (-not (Test-Path $configDir)) { New-Item -ItemType Directory -Path $configDir -Force | Out-Null }
if (-not (Test-Path $configPath)) { New-Item -ItemType File -Path $configPath -Force | Out-Null }
$content = Get-Content $configPath -Raw -ErrorAction SilentlyContinue
if ($content -notmatch [regex]::Escape('%s')) {
  Add-Content -Path $configPath -Value "`n%s`n. `"%s`"`n%s"
}
]],
              inputs.config_path,
              inputs.begin_marker,
              inputs.begin_marker,
              inputs.build.outputs.ps1,
              inputs.end_marker
            ),
          },
        })

        return { config = inputs.config_path }
      end,
      destroy = function(outputs, ctx)
        -- Remove our block from the config
        ctx:exec({
          bin = 'powershell.exe',
          args = {
            '-NoProfile',
            '-Command',
            string.format(
              [[
$configPath = '%s'
if (Test-Path $configPath) {
  $content = Get-Content $configPath -Raw
  $pattern = '(?s)%s.*?%s\r?\n?'
  $newContent = $content -replace $pattern, ''
  Set-Content -Path $configPath -Value $newContent -NoNewline
}
]],
              outputs.config,
              BEGIN_MARKER,
              END_MARKER
            ),
          },
        })
      end,
    })
  else
    -- POSIX shells (bash, zsh)
    for _, shell in ipairs({ 'zsh', 'bash' }) do
      local config_path = shell_configs[shell]
      if config_path then
        sys.bind({
          inputs = {
            build = build,
            config_path = config_path,
            shell = shell,
            begin_marker = BEGIN_MARKER,
            end_marker = END_MARKER,
          },
          create = function(inputs, ctx)
            local source_line
            if inputs.shell == 'bash' then
              source_line =
                string.format('[ -f "%s" ] && source "%s"', inputs.build.outputs.sh, inputs.build.outputs.sh)
            else
              source_line = string.format('source "%s"', inputs.build.outputs.sh)
            end

            -- Create config dir/file if needed and add source block
            ctx:exec({
              bin = '/bin/sh',
              args = {
                '-c',
                string.format(
                  [[
config_path="%s"
config_dir=$(dirname "$config_path")
mkdir -p "$config_dir"
touch "$config_path"
if ! grep -qF "%s" "$config_path" 2>/dev/null; then
  printf '\n%s\n%s\n%s\n' >> "$config_path"
fi
]],
                  inputs.config_path,
                  inputs.begin_marker,
                  inputs.begin_marker,
                  source_line,
                  inputs.end_marker
                ),
              },
            })

            return { config = inputs.config_path }
          end,
          destroy = function(outputs, ctx)
            -- Remove our block from the config
            ctx:exec({
              bin = '/bin/sh',
              args = {
                '-c',
                string.format(
                  [[
config_path="%s"
if [ -f "$config_path" ]; then
  sed '/%s/,/%s/d' "$config_path" > "$config_path.tmp" && mv "$config_path.tmp" "$config_path"
fi
]],
                  outputs.config,
                  escape_sed_pattern(BEGIN_MARKER),
                  escape_sed_pattern(END_MARKER)
                ),
              },
            })
          end,
        })
      end
    end

    -- Fish shell
    if shell_configs.fish then
      sys.bind({
        inputs = {
          build = build,
          config_path = shell_configs.fish,
          begin_marker = BEGIN_MARKER,
          end_marker = END_MARKER,
        },
        create = function(inputs, ctx)
          local source_line = string.format('source "%s"', inputs.build.outputs.fish)

          ctx:exec({
            bin = '/bin/sh',
            args = {
              '-c',
              string.format(
                [[
config_path="%s"
config_dir=$(dirname "$config_path")
mkdir -p "$config_dir"
touch "$config_path"
if ! grep -qF "%s" "$config_path" 2>/dev/null; then
  printf '\n%s\n%s\n%s\n' >> "$config_path"
fi
]],
                inputs.config_path,
                inputs.begin_marker,
                inputs.begin_marker,
                source_line,
                inputs.end_marker
              ),
            },
          })

          return { config = inputs.config_path }
        end,
        destroy = function(outputs, ctx)
          ctx:exec({
            bin = '/bin/sh',
            args = {
              '-c',
              string.format(
                [[
config_path="%s"
if [ -f "$config_path" ]; then
  sed '/%s/,/%s/d' "$config_path" > "$config_path.tmp" && mv "$config_path.tmp" "$config_path"
fi
]],
                outputs.config,
                escape_sed_pattern(BEGIN_MARKER),
                escape_sed_pattern(END_MARKER)
              ),
            },
          })
        end,
      })
    end
  end
end

-- ============================================================================
-- Public API
-- ============================================================================

--- Set up environment variables according to the provided options
--- Environment variables are specified as top-level keys (e.g., EDITOR = 'vim')
--- PATH is predefined as mergeable and can be extended with prio.before()/after()
---@param provided_opts syslua.environment.variables.Options
M.setup = function(provided_opts)
  local new_opts, err = prio.merge(M.opts, provided_opts)
  if not new_opts then
    error(string.format('Failed to merge env options: %s', err or 'unknown error'))
  end

  M.opts = new_opts

  -- Create build that generates env files
  local build = create_env_build(M.opts)

  -- Create binds that source env files from shell configs
  create_env_binds(build)
end

return M
