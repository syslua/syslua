local prio = require('syslua.priority')
local lib = require('syslua.lib')

---@class syslua.environment.aliases
local M = {}

---@class syslua.environment.aliases.Options
---@field [string] string | syslua.priority.PriorityValue<string>

local default_opts = {}

---@type syslua.environment.aliases.Options
M.opts = default_opts

-- ============================================================================
-- Helper Functions
-- ============================================================================

--- Escape a string for POSIX shell (bash/zsh) alias value
---@param str string
---@return string
local function escape_posix(str)
  -- Escape single quotes by ending quote, adding escaped quote, starting quote
  return "'" .. str:gsub("'", "'\\''") .. "'"
end

--- Escape a string for fish shell
---@param str string
---@return string
local function escape_fish(str)
  -- Fish uses single quotes with \' for escape
  return "'" .. str:gsub("'", "\\'") .. "'"
end

--- Escape a string for use in sed regex patterns
---@param str string
---@return string
local function escape_sed_pattern(str)
  return str:gsub('([#/\\%.%[%]%*%^%$])', '\\%1')
end

--- Get shell config file paths based on privilege level
---@return table<string, string>
local function get_shell_configs()
  local home = lib.get_home()

  if sys.is_elevated then
    -- Global config paths
    local bash_global = sys.os == 'darwin' and '/etc/profile' or '/etc/profile.d/syslua-alias.sh'
    return {
      zsh = '/etc/zshenv',
      bash = bash_global,
      fish = '/etc/fish/conf.d/syslua-alias.fish',
      powershell = 'C:\\Program Files\\PowerShell\\7\\profile.ps1',
    }
  else
    -- User config paths
    return {
      zsh = home .. '/.zshenv',
      bash = home .. '/.bashrc',
      fish = home .. '/.config/fish/config.fish',
      powershell = home .. '/Documents/PowerShell/profile.ps1',
    }
  end
end

--- Extract aliases from merged opts
---@param opts syslua.environment.aliases.Options
---@return table<string, string>
local function extract_aliases(opts)
  local aliases = {}

  for k, v in pairs(opts) do
    if type(v) == 'string' then
      aliases[k] = v
    end
  end

  return aliases
end

--- Generate bash/zsh alias file content
---@param aliases table<string, string>
---@return string
local function generate_posix_aliases(aliases)
  local lines = {
    '# Generated by syslua - DO NOT EDIT',
    '# This file defines shell aliases managed by syslua',
    '',
  }

  for name, command in pairs(aliases) do
    table.insert(lines, 'alias ' .. name .. '=' .. escape_posix(command))
  end

  table.insert(lines, '')
  return table.concat(lines, '\n')
end

--- Generate fish alias file content
---@param aliases table<string, string>
---@return string
local function generate_fish_aliases(aliases)
  local lines = {
    '# Generated by syslua - DO NOT EDIT',
    '# This file defines shell aliases managed by syslua',
    '',
  }

  for name, command in pairs(aliases) do
    table.insert(lines, 'alias ' .. name .. ' ' .. escape_fish(command))
  end

  table.insert(lines, '')
  return table.concat(lines, '\n')
end

--- Generate PowerShell alias file content
--- Uses functions instead of Set-Alias to support commands with arguments
---@param aliases table<string, string>
---@return string
local function generate_powershell_aliases(aliases)
  local lines = {
    '# Generated by syslua - DO NOT EDIT',
    '# This file defines shell aliases managed by syslua',
    '',
  }

  for name, command in pairs(aliases) do
    -- Use functions for aliases with arguments
    table.insert(lines, string.format('function %s { %s $args }', name, command))
  end

  table.insert(lines, '')
  return table.concat(lines, '\n')
end

-- ============================================================================
-- Build and Bind Steps
-- ============================================================================

--- Create the build step that generates alias files
---@param opts syslua.environment.aliases.Options
---@return table
local function create_alias_build(opts)
  local aliases = extract_aliases(opts)

  return sys.build({
    id = '__syslua_alias',
    replace = true,
    inputs = {
      aliases = aliases,
      os = sys.os,
    },
    create = function(inputs, ctx)
      local posix_content = generate_posix_aliases(inputs.aliases)
      local fish_content = generate_fish_aliases(inputs.aliases)
      local ps_content = generate_powershell_aliases(inputs.aliases)

      -- Write alias files
      if sys.os == 'windows' then
        ctx:exec({
          bin = 'powershell.exe',
          args = {
            '-NoProfile',
            '-Command',
            string.format("Set-Content -Path '%s/syslua-alias.ps1' -Value '%s'", ctx.out, ps_content:gsub("'", "''")),
          },
        })
      else
        ctx:exec({
          bin = '/bin/sh',
          args = {
            '-c',
            string.format('cat > "%s/syslua-alias.sh" << \'SYSLUA_EOF\'\n%sSYSLUA_EOF', ctx.out, posix_content),
          },
        })
        ctx:exec({
          bin = '/bin/sh',
          args = {
            '-c',
            string.format('cat > "%s/syslua-alias.fish" << \'SYSLUA_EOF\'\n%sSYSLUA_EOF', ctx.out, fish_content),
          },
        })
      end

      return {
        sh = ctx.out .. '/syslua-alias.sh',
        fish = ctx.out .. '/syslua-alias.fish',
        ps1 = ctx.out .. '/syslua-alias.ps1',
      }
    end,
  })
end

--- Create bind steps to source alias files from shell configs
---@param build table Build outputs reference
local function create_alias_binds(build)
  local shell_configs = get_shell_configs()

  -- Marker for identifying our block
  local BEGIN_MARKER = '# BEGIN SYSLUA ALIAS - DO NOT EDIT'
  local END_MARKER = '# END SYSLUA ALIAS'

  if sys.os == 'windows' then
    -- PowerShell bind
    sys.bind({
      inputs = {
        build = build,
        config_path = shell_configs.powershell,
        begin_marker = BEGIN_MARKER,
        end_marker = END_MARKER,
      },
      create = function(inputs, ctx)
        ctx:exec({
          bin = 'powershell.exe',
          args = {
            '-NoProfile',
            '-Command',
            string.format(
              [[
$configPath = '%s'
$configDir = Split-Path -Parent $configPath
if (-not (Test-Path $configDir)) { New-Item -ItemType Directory -Path $configDir -Force | Out-Null }
if (-not (Test-Path $configPath)) { New-Item -ItemType File -Path $configPath -Force | Out-Null }
$content = Get-Content $configPath -Raw -ErrorAction SilentlyContinue
if ($content -notmatch [regex]::Escape('%s')) {
  Add-Content -Path $configPath -Value "`n%s`n. `"%s`"`n%s"
}
]],
              inputs.config_path,
              inputs.begin_marker,
              inputs.begin_marker,
              inputs.build.outputs.ps1,
              inputs.end_marker
            ),
          },
        })

        return { config = inputs.config_path }
      end,
      destroy = function(outputs, ctx)
        ctx:exec({
          bin = 'powershell.exe',
          args = {
            '-NoProfile',
            '-Command',
            string.format(
              [[
$configPath = '%s'
if (Test-Path $configPath) {
  $content = Get-Content $configPath -Raw
  $pattern = '(?s)%s.*?%s\r?\n?'
  $newContent = $content -replace $pattern, ''
  Set-Content -Path $configPath -Value $newContent -NoNewline
}
]],
              outputs.config,
              BEGIN_MARKER,
              END_MARKER
            ),
          },
        })
      end,
    })
  else
    -- POSIX shells (bash, zsh)
    for _, shell in ipairs({ 'zsh', 'bash' }) do
      local config_path = shell_configs[shell]
      if config_path then
        sys.bind({
          inputs = {
            build = build,
            config_path = config_path,
            shell = shell,
            begin_marker = BEGIN_MARKER,
            end_marker = END_MARKER,
          },
          create = function(inputs, ctx)
            local source_line
            if inputs.shell == 'bash' then
              source_line =
                string.format('[ -f "%s" ] && source "%s"', inputs.build.outputs.sh, inputs.build.outputs.sh)
            else
              source_line = string.format('source "%s"', inputs.build.outputs.sh)
            end

            ctx:exec({
              bin = '/bin/sh',
              args = {
                '-c',
                string.format(
                  [[
config_path="%s"
config_dir=$(dirname "$config_path")
mkdir -p "$config_dir"
touch "$config_path"
if ! grep -qF "%s" "$config_path" 2>/dev/null; then
  printf '\n%s\n%s\n%s\n' >> "$config_path"
fi
]],
                  inputs.config_path,
                  inputs.begin_marker,
                  inputs.begin_marker,
                  source_line,
                  inputs.end_marker
                ),
              },
            })

            return { config = inputs.config_path }
          end,
          destroy = function(outputs, ctx)
            ctx:exec({
              bin = '/bin/sh',
              args = {
                '-c',
                string.format(
                  [[
config_path="%s"
if [ -f "$config_path" ]; then
  sed '/%s/,/%s/d' "$config_path" > "$config_path.tmp" && mv "$config_path.tmp" "$config_path"
fi
]],
                  outputs.config,
                  escape_sed_pattern(BEGIN_MARKER),
                  escape_sed_pattern(END_MARKER)
                ),
              },
            })
          end,
        })
      end
    end

    -- Fish shell
    if shell_configs.fish then
      sys.bind({
        inputs = {
          build = build,
          config_path = shell_configs.fish,
          begin_marker = BEGIN_MARKER,
          end_marker = END_MARKER,
        },
        create = function(inputs, ctx)
          local source_line = string.format('source "%s"', inputs.build.outputs.fish)

          ctx:exec({
            bin = '/bin/sh',
            args = {
              '-c',
              string.format(
                [[
config_path="%s"
config_dir=$(dirname "$config_path")
mkdir -p "$config_dir"
touch "$config_path"
if ! grep -qF "%s" "$config_path" 2>/dev/null; then
  printf '\n%s\n%s\n%s\n' >> "$config_path"
fi
]],
                inputs.config_path,
                inputs.begin_marker,
                inputs.begin_marker,
                source_line,
                inputs.end_marker
              ),
            },
          })

          return { config = inputs.config_path }
        end,
        destroy = function(outputs, ctx)
          ctx:exec({
            bin = '/bin/sh',
            args = {
              '-c',
              string.format(
                [[
config_path="%s"
if [ -f "$config_path" ]; then
  sed '/%s/,/%s/d' "$config_path" > "$config_path.tmp" && mv "$config_path.tmp" "$config_path"
fi
]],
                outputs.config,
                escape_sed_pattern(BEGIN_MARKER),
                escape_sed_pattern(END_MARKER)
              ),
            },
          })
        end,
      })
    end
  end
end

-- ============================================================================
-- Public API
-- ============================================================================

--- Set up shell aliases according to the provided options
--- Aliases are specified as top-level keys (e.g., ll = 'ls -la')
--- Multiple calls accumulate aliases; use prio.force() to override
---@param provided_opts syslua.environment.aliases.Options
M.setup = function(provided_opts)
  local new_opts, err = prio.merge(M.opts, provided_opts)
  if not new_opts then
    error(string.format('Failed to merge alias options: %s', err or 'unknown error'))
  end

  M.opts = new_opts

  -- Create build that generates alias files
  local build = create_alias_build(M.opts)

  -- Create binds that source alias files from shell configs
  create_alias_binds(build)
end

return M
