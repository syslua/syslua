//! Environment script generation

use crate::error::CoreError;
use crate::manifest::Manifest;
use std::fs;
use std::path::Path;
use sys_lua::{EnvDecl, EnvMergeStrategy};
use sys_platform::Shell;

/// Generate environment script content for a specific shell
pub fn generate_env_script(manifest: &Manifest, shell: &Shell) -> String {
    let mut lines = Vec::new();

    // Header
    lines.push(shell.header().to_string());
    lines.push(shell.comment("Generated by sys.lua - DO NOT EDIT"));
    lines.push(shell.comment(&format!(
        "Generated at: {}",
        chrono::Local::now().format("%Y-%m-%d %H:%M:%S")
    )));
    lines.push(String::new());

    // Sort env vars for deterministic output
    let mut envs: Vec<_> = manifest.envs.iter().collect();
    envs.sort_by(|a, b| a.name.cmp(&b.name));

    for env in envs {
        lines.extend(generate_env_var_lines(env, shell));
    }

    lines.join("\n")
}

/// Generate lines for a single environment variable
fn generate_env_var_lines(env: &EnvDecl, shell: &Shell) -> Vec<String> {
    let mut lines = Vec::new();

    for value in &env.values {
        let line = match value.strategy {
            EnvMergeStrategy::Replace => shell.export_var(&env.name, &value.value),
            EnvMergeStrategy::Prepend => shell.prepend_path(&env.name, &value.value),
            EnvMergeStrategy::Append => shell.append_path(&env.name, &value.value),
        };
        lines.push(line);
    }

    lines
}

/// Write environment scripts for all supported shells
pub fn write_env_scripts(manifest: &Manifest, env_dir: &Path) -> Result<Vec<Shell>, CoreError> {
    // Create the directory if it doesn't exist
    if !env_dir.exists() {
        fs::create_dir_all(env_dir)?;
    }

    let shells = [Shell::Bash, Shell::Zsh, Shell::Fish, Shell::Sh];
    let mut written = Vec::new();

    for shell in &shells {
        let content = generate_env_script(manifest, shell);
        let filename = format!("env.{}", shell.script_extension());
        let path = env_dir.join(&filename);

        fs::write(&path, &content)?;
        written.push(*shell);
    }

    Ok(written)
}

/// Generate the source command for a shell's env script
pub fn source_command(shell: &Shell, env_dir: &Path) -> String {
    let script_path = env_dir.join(format!("env.{}", shell.script_extension()));
    let path_str = script_path.display();

    match shell {
        Shell::Fish => format!("source \"{}\"", path_str),
        Shell::PowerShell => format!(". \"{}\"", path_str),
        Shell::Bash | Shell::Zsh | Shell::Sh => format!("source \"{}\"", path_str),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use sys_lua::EnvValue;

    fn test_manifest() -> Manifest {
        let mut manifest = Manifest::new();
        manifest.add_env(EnvDecl::new("EDITOR", "nvim"));
        manifest.add_env(EnvDecl {
            name: "PATH".to_string(),
            values: vec![
                EnvValue::prepend("/usr/local/bin".to_string()),
                EnvValue::prepend("/opt/bin".to_string()),
            ],
        });
        manifest
    }

    #[test]
    fn test_generate_bash_script() {
        let manifest = test_manifest();
        let script = generate_env_script(&manifest, &Shell::Bash);

        assert!(script.contains("#!/usr/bin/env bash"));
        assert!(script.contains("Generated by sys.lua"));
        assert!(script.contains(r#"export EDITOR="nvim""#));
        assert!(script.contains(r#"export PATH="/usr/local/bin":$PATH"#));
    }

    #[test]
    fn test_generate_fish_script() {
        let manifest = test_manifest();
        let script = generate_env_script(&manifest, &Shell::Fish);

        assert!(script.contains("Fish shell environment"));
        assert!(script.contains(r#"set -gx EDITOR "nvim""#));
        assert!(script.contains(r#"set -gx PATH "/usr/local/bin" $PATH"#));
    }

    #[test]
    fn test_generate_zsh_script() {
        let manifest = test_manifest();
        let script = generate_env_script(&manifest, &Shell::Zsh);

        assert!(script.contains("#!/usr/bin/env zsh"));
        assert!(script.contains(r#"export EDITOR="nvim""#));
    }

    #[test]
    fn test_source_command_bash() {
        let cmd = source_command(&Shell::Bash, Path::new("/home/user/.config/syslua/env"));
        assert!(cmd.contains("source"));
        assert!(cmd.contains("env.sh"));
    }

    #[test]
    fn test_source_command_fish() {
        let cmd = source_command(&Shell::Fish, Path::new("/home/user/.config/syslua/env"));
        assert!(cmd.contains("source"));
        assert!(cmd.contains("env.fish"));
    }

    #[test]
    fn test_write_env_scripts() {
        let manifest = test_manifest();
        let temp_dir = tempfile::tempdir().unwrap();

        let written = write_env_scripts(&manifest, temp_dir.path()).unwrap();

        assert!(!written.is_empty());
        assert!(temp_dir.path().join("env.sh").exists());
        assert!(temp_dir.path().join("env.zsh").exists());
        assert!(temp_dir.path().join("env.fish").exists());

        // Verify content
        let bash_content = fs::read_to_string(temp_dir.path().join("env.sh")).unwrap();
        assert!(bash_content.contains("EDITOR"));
    }

    #[test]
    fn test_append_strategy() {
        let mut manifest = Manifest::new();
        manifest.add_env(EnvDecl {
            name: "MANPATH".to_string(),
            values: vec![EnvValue::append("/usr/share/man".to_string())],
        });

        let script = generate_env_script(&manifest, &Shell::Bash);
        assert!(script.contains(r#"export MANPATH=$MANPATH:"/usr/share/man""#));
    }
}
